<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contemporary Artifacts - Dinnerware Collection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f0;
            overflow: hidden;
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Item labels - SADECE HOVER'DA GÖRÜNÜR */
        .item-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            white-space: nowrap;
        }

        .item-label.visible {
            opacity: 1;
        }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            padding: 12px 24px;
            border-radius: 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .control-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }

        .control-btn.active {
            background: #333;
            color: white;
        }

        /* Grid Mode Container */
        #gridContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f5f5f0;
            opacity: 0;
            pointer-events: none;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 50;
            transition: opacity 0.5s ease;
            padding: 100px 40px 40px 40px;
        }

        #gridContainer.active {
            opacity: 1;
            pointer-events: all;
        }

        .grid-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .grid-header h1 {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #333;
            margin-bottom: 10px;
        }

        .grid-wrapper {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 40px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .grid-item {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            transform: scale(0);
            opacity: 0;
        }

        .grid-item.visible {
            transform: scale(1);
            opacity: 1;
        }

        .grid-item:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        }

        .grid-item img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .grid-item-name {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
        }

        .grid-item-collection {
            font-size: 14px;
            color: #666;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 32px;
            border-radius: 24px;
            font-size: 14px;
            color: #666;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: opacity 0.3s ease;
        }

        .instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 1400px) {
            .grid-wrapper {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 900px) {
            .grid-wrapper {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .grid-header h1 {
                font-size: 32px;
            }
        }

        @media (max-width: 600px) {
            .grid-wrapper {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Hover Label -->
    <div class="item-label" id="hoverLabel"></div>

    <!-- Instructions -->
    <div class="instructions" id="instructions">
        Sürükleyerek keşfet • Zoom için mouse tekerleği
    </div>

    <!-- Controls -->
    <div class="controls" id="controls">
        <button class="control-btn" id="resetBtn">Sıfırla</button>
        <button class="control-btn" id="gridBtn">Grid Görünüm</button>
    </div>

    <!-- Grid Container -->
    <div id="gridContainer">
        <div class="grid-header">
            <h1>CONTEMPORARY ARTIFACTS</h1>
        </div>
        <div class="grid-wrapper" id="gridWrapper"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Her itemi 3 kez kullan
        const REPEAT_ITEMS = 3;

        // Items data - Ana Palmer sitesinden
        const items = [
            { name: "Miami Cup 29 cl", collection: "Miami", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96ff7007ac9e6adec49c9_Miami%20Cup%2029.webp" },
            { name: "Ruston Deep Plate ⌀ 22 cm", collection: "Ruston", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d970f693523015543171c7_Ruston%20Deep%20plate%2022.webp" },
            { name: "Lotus Plate ⌀ 27,5 cm", collection: "Lotus", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96fc713c57d797697764a_Lotus%20Plate%2027%2C5.webp" },
            { name: "Antigo Light Blue Plate ⌀ 28 cm", collection: "Antigo Light Blue", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96be3fd9b1c20bb3d0bfd_Antigo%20Lightblue%20Plate%2028.webp" },
            { name: "Miami Deep Plate ⌀ 22 cm", collection: "Miami", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d97012741b605f32ba31c2_Miami%20Deep%20plate%2022.webp" },
            { name: "Antigo Blue Deep Plate ⌀ 19 cm", collection: "Antigo Blue", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96b54786ce434bda8e599_Antigo%20blue%20Deep%20plate%2019.webp" },
            { name: "Coco Pink Bowl ⌀ 12 cm", collection: "Coco Pink", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/6836df1e54830ce31b5fd72a_Bowl%2013.webp" },
            { name: "Antigo Blue Plate ⌀ 19 cm", collection: "Antigo Blue", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96b612294f58747319457_Antigo%20blue%20Plate%2019.webp" },
            { name: "Kiryu Bowl ⌀ 14 cm", collection: "Kiryu", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96e9e117eab84723eb18b_Kiryu%20Bowl%2014.webp" },
            { name: "Sandy Loam Grey Plate ⌀ 28 cm", collection: "Sandy Loam Grey", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d971d33163f9824c3b53d5_Sandy%20Loam%20Grey%20Plate%2028.webp" },
            { name: "Coco Green Plate ⌀ 19 cm", collection: "Coco Green", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/6836dfe00c3d21f37b42b89b_Plate%2019-2.webp" },
            { name: "Eccentric Bowl ⌀ 11 cm", collection: "Eccentric", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96d82c5610dcb465b9e24_Eccentric%20Bowl%2011.webp" },
            { name: "Midori Bowl ⌀ 12,5 cm", collection: "Midori", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d97091b598af20f0a5b912_Midori%20Bowl%2012%2C5.webp" },
            { name: "Lotus Deep Plate ⌀ 21 cm", collection: "Lotus", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96faa29e92d2c7a7ca681_Lotus%20Deep%20plate%2021.webp" },
            { name: "Midori Bowl ⌀ 14 cm", collection: "Midori", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d970a40f53ceaad652bcfa_Midori%20Bowl%2014.webp" },
            { name: "Kiryu Bowl ⌀ 12,5 cm", collection: "Kiryu", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96e928ecc7b3bd19d4b83_Kiryu%20Bowl%2012%2C5.webp" },
            { name: "Eccentric Deep Plate ⌀ 22 cm", collection: "Eccentric", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96df2ab0def13c182eddf_Eccentric%20deep%20plate%2022.webp" },
            { name: "Antigo Creme Plate ⌀ 28 cm", collection: "Antigo Creme", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96b9356d92c0249950136_Antigo%20Creme%20Plate%2028.webp" },
            { name: "Light Blue Sea Plate ⌀ 28,5 cm", collection: "Light Blue Sea", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96f69fa52228ca041aadb_Light%20Blue%20Sea%20Plate%2028.webp" },
            { name: "Light Blue Sea Bowl ⌀ 16 cm", collection: "Light Blue Sea", image: "https://cdn.prod.website-files.com/677b8a552071e1f09b594a24/67d96efac6037c23fa15d6c4_Light%20Blue%20Sea%20Bowl%2016.webp" },
        ];

        // Her itemi REPEAT_ITEMS kere çoğalt
        const allItems = [];
        for (let i = 0; i < REPEAT_ITEMS; i++) {
            allItems.push(...items);
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f0);

        const camera = new THREE.PerspectiveCamera(
            50,
            window.innerWidth / window.innerHeight,
            0.1,
            2000
        );

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        // Meshes container
        const meshes = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // BAŞLANGIÇ: ÇOK ZOOM OUT (3x zoom out)
        camera.position.set(0, 0, 150);

        // Scattered positions - DAĞINIK DÜZENkaydetmek için
        function getScatteredPosition(index, total) {
            const radius = 50;
            const angle = (index / total) * Math.PI * 2;
            const randomRadius = radius + (Math.random() - 0.5) * 40;
            const randomAngle = angle + (Math.random() - 0.5) * 1.0;

            return {
                x: Math.cos(randomAngle) * randomRadius,
                y: (Math.random() - 0.5) * 60,
                z: (Math.random() - 0.5) * 40
            };
        }

        // Load textures and create meshes
        const textureLoader = new THREE.TextureLoader();
        const loadPromises = [];

        allItems.forEach((item, index) => {
            const promise = new Promise((resolve) => {
                textureLoader.load(
                    item.image,
                    (texture) => {
                        const aspect = texture.image.width / texture.image.height;
                        const width = 8;
                        const height = width / aspect;

                        const geometry = new THREE.PlaneGeometry(width, height);
                        const material = new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            transparent: true
                        });

                        const mesh = new THREE.Mesh(geometry, material);

                        // DAĞINIK POZİSYON
                        const pos = getScatteredPosition(index, allItems.length);
                        mesh.position.set(pos.x, pos.y, pos.z);

                        // Random rotation
                        mesh.rotation.y = (Math.random() - 0.5) * 0.3;

                        mesh.userData = {
                            name: item.name,
                            collection: item.collection,
                            image: item.image,
                            originalPosition: { ...pos },
                            originalRotation: { ...mesh.rotation }
                        };

                        scene.add(mesh);
                        meshes.push(mesh);
                        resolve();
                    },
                    undefined,
                    () => resolve()
                );
            });
            loadPromises.push(promise);
        });

        // Wait for all textures to load
        Promise.all(loadPromises).then(() => {
            console.log('Tüm objeler yüklendi:', meshes.length);
        });

        // Mouse/Touch interaction
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let velocity = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        // Hover label
        const hoverLabel = document.getElementById('hoverLabel');
        let hoveredMesh = null;

        function onMouseMove(event) {
            // Update mouse position for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && meshes.length > 0) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                velocity.x = deltaX * 0.005;
                velocity.y = deltaY * 0.005;

                targetRotation.y += velocity.x;
                targetRotation.x += velocity.y;
                targetRotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetRotation.x));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }

            // Hover detection - SADECE HOVER'DA İSİM GÖSTER
            if (!isDragging && meshes.length > 0) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    if (hoveredMesh !== mesh) {
                        hoveredMesh = mesh;
                        hoverLabel.textContent = mesh.userData.name;
                        hoverLabel.classList.add('visible');
                    }
                    hoverLabel.style.left = event.clientX + 20 + 'px';
                    hoverLabel.style.top = event.clientY + 20 + 'px';
                } else {
                    if (hoveredMesh) {
                        hoveredMesh = null;
                        hoverLabel.classList.remove('visible');
                    }
                }
            }
        }

        function onMouseDown(event) {
            isDragging = true;
            document.body.classList.add('grabbing');
            previousMousePosition = { x: event.clientX, y: event.clientY };
            hoverLabel.classList.remove('visible');
        }

        function onMouseUp() {
            isDragging = false;
            document.body.classList.remove('grabbing');
        }

        // Zoom with wheel
        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 5;
            const minZoom = 30;
            const maxZoom = 200;

            camera.position.z += event.deltaY * 0.01 * zoomSpeed;
            camera.position.z = Math.max(minZoom, Math.min(maxZoom, camera.position.z));

            // POP EFFECT - zoom yaparken items pop eder
            meshes.forEach((mesh, index) => {
                const delay = index * 0.01;
                setTimeout(() => {
                    const scale = 1 + Math.abs(event.deltaY) * 0.0005;
                    mesh.scale.set(scale, scale, scale);
                    setTimeout(() => {
                        mesh.scale.set(1, 1, 1);
                    }, 100);
                }, delay * 10);
            });
        }

        // Event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('wheel', onWheel, { passive: false });

        // Touch events
        let touchStartDistance = 0;
        let lastTouchY = 0;

        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchStartDistance = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
            } else if (e.touches.length === 1) {
                isDragging = true;
                lastTouchY = e.touches[0].clientY;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const currentDistance = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                const delta = touchStartDistance - currentDistance;
                camera.position.z += delta * 0.1;
                camera.position.z = Math.max(30, Math.min(200, camera.position.z));
                touchStartDistance = currentDistance;
            } else if (isDragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                velocity.x = deltaX * 0.005;
                velocity.y = deltaY * 0.005;

                targetRotation.y += velocity.x;
                targetRotation.x += velocity.y;
                targetRotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetRotation.x));

                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            camera.position.set(0, 0, 150);
            targetRotation = { x: 0, y: 0 };
            currentRotation = { x: 0, y: 0 };

            meshes.forEach(mesh => {
                const pos = mesh.userData.originalPosition;
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.rotation.copy(mesh.userData.originalRotation);
            });
        });

        // Grid mode
        const gridContainer = document.getElementById('gridContainer');
        const gridWrapper = document.getElementById('gridWrapper');
        const gridBtn = document.getElementById('gridBtn');
        const controls = document.getElementById('controls');
        const instructions = document.getElementById('instructions');
        let isGridMode = false;

        gridBtn.addEventListener('click', () => {
            isGridMode = !isGridMode;

            if (isGridMode) {
                // Grid moduna geç
                // 1. Önce tüm meshler scale 0 olsun
                meshes.forEach(mesh => {
                    mesh.scale.set(0, 0, 0);
                });

                setTimeout(() => {
                    gridContainer.classList.add('active');
                    controls.classList.add('hidden');
                    instructions.classList.add('hidden');
                    gridBtn.textContent = '3D Görünüm';
                    gridBtn.classList.add('active');

                    // Grid items oluştur
                    gridWrapper.innerHTML = '';
                    allItems.forEach((item, index) => {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'grid-item';
                        gridItem.innerHTML = `
                            <img src="${item.image}" alt="${item.name}">
                            <div class="grid-item-name">${item.name}</div>
                            <div class="grid-item-collection">${item.collection}</div>
                        `;
                        gridWrapper.appendChild(gridItem);

                        // Staggered animation
                        setTimeout(() => {
                            gridItem.classList.add('visible');
                        }, index * 30);
                    });
                }, 300);

            } else {
                // 3D moduna dön
                gridContainer.classList.remove('active');
                controls.classList.remove('hidden');
                instructions.classList.remove('hidden');
                gridBtn.textContent = 'Grid Görünüm';
                gridBtn.classList.remove('active');

                // Meshları tekrar göster - POP efekti ile
                meshes.forEach((mesh, index) => {
                    setTimeout(() => {
                        mesh.scale.set(0, 0, 0);
                        setTimeout(() => {
                            mesh.scale.set(1.2, 1.2, 1.2);
                            setTimeout(() => {
                                mesh.scale.set(1, 1, 1);
                            }, 100);
                        }, 10);
                    }, index * 20);
                });
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!isGridMode && meshes.length > 0) {
                // Smooth rotation
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

                // Apply rotation to all meshes
                meshes.forEach(mesh => {
                    const originalPos = mesh.userData.originalPosition;
                    const x = originalPos.x;
                    const y = originalPos.y;
                    const z = originalPos.z;

                    // Rotate around center
                    const cosY = Math.cos(currentRotation.y);
                    const sinY = Math.sin(currentRotation.y);
                    const cosX = Math.cos(currentRotation.x);
                    const sinX = Math.sin(currentRotation.x);

                    const rotatedX = x * cosY - z * sinY;
                    const rotatedZ = x * sinY + z * cosY;
                    const rotatedY = y * cosX - rotatedZ * sinX;
                    const finalZ = y * sinX + rotatedZ * cosX;

                    mesh.position.x = rotatedX;
                    mesh.position.y = rotatedY;
                    mesh.position.z = finalZ;
                });

                // Damping
                velocity.x *= 0.95;
                velocity.y *= 0.95;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide instructions after 3 seconds
        setTimeout(() => {
            instructions.style.opacity = '0';
            setTimeout(() => {
                instructions.style.display = 'none';
            }, 300);
        }, 3000);
    </script>
</body>
</html>
